--------------------------------------------------------------------------------
스프링 프로젝트 생성_01
	ㄴ 1. 스프링 프로젝트 생성
	ㄴ 2. configure -> convert to maven project (pom.xml이 생성됨)
	ㄴ 3. Spring -> add spring project nature
	ㄴ 4. mvnrepository.com
		ㄴ 4_1. spring context -> 다운로드가 많은 버전으로.. -> 5.2.0 RELEASE
		ㄴ 4_2. pom.xml build 태그 아래에 dependencies 태그 안에 depency태그들로 작성을 하면 알아서 관련 라이브러리를 다운받아옴
	ㄴ ***** 프로젝트명만 문제가 생기거나, pom.xml에 문제가 생겼을 경우
		ㄴ m2.repository를 지우면 됨	
--------------------------------------------------------------------------------
스프링 프로젝트 생성_02
	ㄴ 
	ㄴ tomcat 설정
		ㄴ server view에서 서버 선택 -> modules 선택 -> path를 "/project_name"으로 변경, AutoReloaded 체크해제
	ㄴ web.xml
		ㄴ webapp -> WEB-INF -> web.xml -> appServlet의 url-pattern을 원하는 대로 설정
			ㄴ ex) <url-pattern>*.do</url-pattern>
	ㄴ servlet-context.xml
		ㄴ webapp -> WEB-INF -> spring -> appServlet -> servlet-context.xml
		ㄴ scanner 폴더 선택
			ㄴ ex) <context:component-scan base-package="com.javassem" />
	ㄴ 한글 인코딩
		ㄴ webapp -> WEB-INF -> web.xml
		<!-- 한글 인코딩 -->
		<filter>
			<filter-name>characterEncoding</filter-name>
			<filter-class>org.springframework.web.filter.CharacterEncodingFilter
			</filter-class>
			<init-param>
				<param-name>encoding</param-name>
				<param-value>UTF-8</param-value>
			</init-param>
		</filter>
		<filter-mapping>
			<filter-name>characterEncoding</filter-name>
			<url-pattern>/*</url-pattern>
		</filter-mapping>
--------------------------------------------------------------------------------
DI
	ㄴ Spring Bean Configuration File 생성
	ㄴ <bean>태그로 객체를 정의?..
		ㄴ <bean id= 'bean_name' class='classpath'> </bean>
			ㄴ scope='singleton'
				ㄴ xml파일을 읽어들일 때 객체를 생성함(scope의 default값)					
				ㄴ 사용법 : <bean id= 'bean_name' class='classpath' scope='singleton'> </bean>
				ㄴ spring의 singleton은 "Spring Container"에 의해 구현된다.
					ㄴ thread safety를 자동으로 보장
			ㄴ scope='prototype'
				ㄴ getBean() 메소드 호출시에 객체를 생성함
				ㄴ 사용법 : <bean id= 'bean_name' class='classpath' scope='prototype'> </bean>
	ㄴ 객체 생성법
		ㄴ ApplicationContext context = new ClassPathXmlApplicationContext(xml_file_name)
			ㄴ 설정파일을 읽어옴
		ㄴ context.getBean("", className.class);
			ㄴ .class <-> .getClass()
				ㄴ .class 는 정적으로 클래스를 가져옴, 클래스의 이름을 통해서
				ㄴ .getClass()는 동적으로 클래스를 가져오고, 생성된 객체의 변수를 통해서 가져옴
--------------------------------------------------------------------------------
Srping Bean 관련 용어
	ㄴ Bean : Spring이 IoC 방식으로 관리하는 객체
		ㄴ Spring이 직접 생성과 제어를 담당하는 객체
	ㄴ BeanFactory : 스프링의 IoC를 담당하는 핵심 컨테이너
		ㄴ Bean을 등록, 생성,  조회, 반환하는 기능을 담당
		ㄴ BeanFactory를 바로 사용하지 않고 확장된 개념인 ApplicationContext를 주로 사용함
	ㄴ ApplicationContext : BeanFactory를 확장한 IoC 컨테이너
		ㄴ Bean을 등록하고 관리하는 기능은 BeanFactory와 동일하지만 스프링에 제공하는 각종 부가 기능이 추가로 존재함
		ㄴ 사용 예시
			ㄴ ApplicationContext context = new ClassPathXmlApplicationContext(FILE_PATH);
			ㄴ 1. BeanClassName bean = context.getBean("bean_id", BeanClassName.class);
			ㄴ 2. BeanClassName bean = (BeanClassName)context.getBean("bean_id");
				ㄴ context.getBean이 기본적으로 Object를 반환하기 때문에 두번째 인자로 ClassName.class를 입력해주거나, 형변환을 해줘야함
--------------------------------------------------------------------------------
Spring_Bean Attribute
	ㄴ class : 정규화된 자바 클래스 이름
	ㄴ id : bean의 고유 식별자
	ㄴ scope : 객체의 범위(singleton, prototype)
	ㄴ construcotr-arg : 생성시 생성자에 전달할 인수
		ㄴ bean을 생성자로 받을시에는 ref 속성에 지정 (***** value <-> ref *****)
			ㄴ 사용예시 : <constructor-arg ref="member">  </constructor-arg>
		ㄴ index와 name 속성을 이용해서 애매한 parameter를 지정가능
	ㄴ property : 생성시 bean setter에 전달할 인수
	ㄴ init method와 destroy method
--------------------------------------------------------------------------------
Spring_Bean pvalue
	ㄴ namespace에서 p체크 혹은 beans에 xmlns:p~추가
	ㄴ 쓸 일이 많지 않음	
--------------------------------------------------------------------------------
Spring_Bean Annotation
	ㄴ namespace에서 context추가
		ㄴ 사용예시 : <context:component-scan base-package="target_package"></context:component-scan>
	ㄴ Annotation 종류
		ㄴ @Component : component임을 알림..
			ㄴ@Component("별칭") : 클래스명에서 앞글자만 소문자로 바뀐 id외에 별칭으로 id를 지정하고 싶을 경우에 사용
		ㄴ @Autowired : 생성자 혹은 setter가 없이 주입해주는 어노테이션(DI : Dependency Injection)
		ㄴ @Qualifier("지정하고싶은_id") : 동일한 클래스의 빈이 여러개일 경우 선택해주는 어노테이션
		ㄴ @Resource(name="지정하고싶은_id") : autowired와 qualifier를 같이 사용한 효과
		ㄴ @Inject : @Autowired와 동일한 기능
		ㄴ 클래스를 분류하기 위한 Annotation(기본적으로 @Component를 상속한 Annotation)
			ㄴ @Service : 비즈니스 로직을 처리하는 Serivce 클래스임을 알림
			ㄴ @Repository : 데이터베이스 연동을 처리하는 DAO 클래스
			ㄴ @Controller : 사용자 요청을 제어하는 Controller 클래스
		ㄴ @RequestMapping : controller 클래스 내부 메소드들에서 사용
			ㄴ requestMapping한 함수에 return형이 String인 경우 : ViewPage를 지정한 것임
				ㄴ requestMapping한 함수가 void인 경우 : 요청과 동일한 이름의 ViewPage를 지정함
			ㄴ 사용예시 : @RequestMapping("/start.do") // start.do url이 들어올경우에만 mapping을 함
			ㄴ 사용예시2 : @RequestMapping(value={"/a.do", "/b.do"})
			ㄴ 쿼리스트링으로 넘어오는 값들은 requestMapping한 함수의 parameter로 받아올 수 있음
				ㄴ 사용예시1_1 : <a href="board/c.do?id=kim">요청3</a>
				ㄴ 사용예시1_2 : public void test2(String id) --> 위의 parameter id값을 가져옴
			ㄴ JSTL에서 parameter로 넘겨받은 값들을 받는법
				ㄴ ${param.param_name}
		ㄴ @RequestParam
			ㄴ 사용예시 : public String test(String id, @RequestParam(defaultValue = "0")int age)
				ㄴ age변수의 default값을 0으로,,
			ㄴ 사용예시 : public String test(@RequestParam(value="id")String userId, @RequestParam(defaultValue = "0")int age)
				ㄴ id값을 받아와서 userId에 넣어놓음
		ㄴ @ModelAttribute("model_attr_name")
			ㄴ model_attr_name에 해당하는 클래스의 객체로 묶어서 다음화면으로 보냄
		ㄴ@ContextConfiguration : configuration 파일 연결?...
			ㄴ 사용예시 : @ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
		ㄴ @Test : 테스팅할 메소드에 지정
		ㄴ @RunWith
			ㄴ 사용예시 : @RunWith(SpringJUnit4ClassRunner.class)
		ㄴ @Log4j : lombok 필요...?
	ㄴ bean을 이용해서 객체 생성시 클래스 이름에서 맨 앞글자를 소문자로 바꾼 형태로 자동으로 만들어줌
--------------------------------------------------------------------------------
Spring_Bean DI
	ㄴ Autowired : setter, constructor가 없지만 Spring 내부적으로 객체를 관리해주고 그 객체를 인지하고 있음
		ㄴ 의존성 주입(Dependancy Injection)
--------------------------------------------------------------------------------
AOP : Aspect Oriented Programming
	ㄴ 핵심기능(Business Logic)과 횡단관심사(Cross-Cutting Concern)
		ㄴ Business Logic : 업무 로직을 포함하는 기능
		ㄴ Cross-Cutting Concern : 핵심기능을 도와주는 부가기능
			ㄴ Logging
			ㄴ Security
			ㄴ Transaction
	ㄴ Application에서의 핵심적인 기능에서 부가적인 기능을 분리
		ㄴ 분리한 부가기능을 Aspect라는 독특한 Module의 형태로 만들어서 설계하고 개발하는 방법
	ㄴ 반복되는 작업들을 Advice로 묶어 원하는 호출지점인 각각의 pointcut에 weaving (기존에 반복되던 작업들을 method로 묶어서 호출하던 것과 다름)
--------------------------------------------------------------------------------
AOP 용어
	ㄴ 타겟(Target) : 핵심기능을 담고 있는 모듈로, 타겟은 부가기능을 부여할 대상
	ㄴ 어드바이스(Advice) : 횡단관심사를 실제로 구현해서 처리하는 부분
	ㄴ 조인 포인트(Join Point) : 횡단관심사가 실행되는 시점
	ㄴ 포인트컷(PointCut) : Advice를 적용할 Target의 method를 선별하는 정규표현식(Regular Expression)
	ㄴ Aspect : AOP의 단위가 되는 횡단관심사
	ㄴ Weaving : 위빙은 포인트컷에 의해서 결정된 타켓의 조인포인트에 부가기능을 삽입하는 과정
--------------------------------------------------------------------------------
AOP Advice의 종류
	ㄴ Around : JoinPoint 의 앞과 뒤에서 실행되는 Advice
	ㄴ Before
	ㄴ After
	ㄴ After Returning : Joinpoint 메소드 호출이 정상적으로 종료된 뒤에 실행되는 Advice
	ㄴ After Throwing : 예외가 던져질 때 실행되는 Advice
--------------------------------------------------------------------------------
AOP 사용 예시
	ㄴ xml 구조
		ㄴ <aop:config>
			<aop:pointcut expression="execution(access_modifier return_type_expression file_path_expression method_expression(param_type_expression) )"></aop:pointcut>
				ㄴ param_type_expression : (..) -> 매개변수를 신경쓰지 않음
			<aop:aspect id='my_aspect_id' ref='my_advice_id' order='my_aspect_sequence'>
				<aop:~>
					ㄴaop:의 종류 : aop:before, aop:around ..
				</aop:~>
			</aop:aspect>
		    </aop:config>
	ㄴ annotation 방식
		ㄴ In XML : Spring 내부적으로 자동연결하는 방법
			ㄴ <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
		ㄴ @Around("execution(access_modifier return_type_expression file_path_expression method_expression(param_type_expression) )")
		ㄴ @Aspect : Around annotation이 붙어있는 객체의 앞에 @Component와 같이 붙임
--------------------------------------------------------------------------------
Controller에서 view로 데이터를 넘기는 방법
	ㄴ 1. ModelAndView 객체를 이용
	ㄴ 2. Map 객체 (자바의 HashMap 이용)
	ㄴ 3. Model 객체 ( ******* ModelAndView 혹은 HashMap 처럼 return으로 넘기는 게 아니고 인자로 지정함 *******
		ㄴ 사용 예시 : @RequestMapping(value="/model.do")
		ㄴ 사용 예시 : public void test(Model m){
		ㄴ 사용 예시 : m.addAttribute("message", "팀원님들 뭐 하실래요"); ...}
	ㄴ 4. ModelAttribute 이용
		ㄴ 사용 방법 : @ModelAttribute("model_attr_name")
--------------------------------------------------------------------------------
Lombok
