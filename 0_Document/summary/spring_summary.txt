--------------------------------------------------------------------------------
스프링 프로젝트 생성
	ㄴ 1. 스프링 프로젝트 생성
	ㄴ 2. configure -> convert to maven project (pom.xml이 생성됨)
	ㄴ 3. Spring -> add spring project nature
	ㄴ 4. mvnrepository.com
		ㄴ 4_1. spring context -> 다운로드가 많은 버전으로.. -> 5.2.0 RELEASE
		ㄴ 4_2. pom.xml build 태그 아래에 dependencies 태그 안에 depency태그들로 작성을 하면 알아서 관련 라이브러리를 다운받아옴
	ㄴ ***** 프로젝트명만 문제가 생기거나, pom.xml에 문제가 생겼을 경우
		ㄴ m2.repository를 지우면 됨	
--------------------------------------------------------------------------------
DI
	ㄴ Spring Bean Configuration File 생성
	ㄴ <bean>태그로 객체를 정의?..
		ㄴ <bean id= 'bean_name' class='classpath'> </bean>
			ㄴ scope='singleton'
				ㄴ xml파일을 읽어들일 때 객체를 생성함(scope의 default값)					
				ㄴ 사용법 : <bean id= 'bean_name' class='classpath' scope='singleton'> </bean>
				ㄴ spring의 singleton은 "Spring Container"에 의해 구현된다.
					ㄴ thread safety를 자동으로 보장
			ㄴ scope='prototype'
				ㄴ getBean() 메소드 호출시에 객체를 생성함
				ㄴ 사용법 : <bean id= 'bean_name' class='classpath' scope='prototype'> </bean>
	ㄴ 객체 생성법
		ㄴ ApplicationContext context = new ClassPathXmlApplicationContext(xml_file_name)
			ㄴ 설정파일을 읽어옴
		ㄴ context.getBean("", className.class);
			ㄴ .class <-> .getClass()
				ㄴ .class 는 정적으로 클래스를 가져옴, 클래스의 이름을 통해서
				ㄴ .getClass()는 동적으로 클래스를 가져오고, 생성된 객체의 변수를 통해서 가져옴
--------------------------------------------------------------------------------
Srping Bean 관련 용어
	ㄴ Bean : Spring이 IoC 방식으로 관리하는 객체
		ㄴ Spring이 직접 생성과 제어를 담당하는 객체
	ㄴ BeanFactory : 스프링의 IoC를 담당하는 핵심 컨테이너
		ㄴ Bean을 등록, 생성,  조회, 반환하는 기능을 담당
		ㄴ BeanFactory를 바로 사용하지 않고 확장된 개념인 ApplicationContext를 주로 사용함
	ㄴ ApplicationContext : BeanFactory를 확장한 IoC 컨테이너
		ㄴ Bean을 등록하고 관리하는 기능은 BeanFactory와 동일하지만 스프링에 제공하는 각종 부가 기능이 추가로 존재함
		ㄴ 사용 예시
			ㄴ ApplicationContext context = new ClassPathXmlApplicationContext(FILE_PATH);
			ㄴ 1. BeanClassName bean = context.getBean("bean_id", BeanClassName.class);
			ㄴ 2. BeanClassName bean = (BeanClassName)context.getBean("bean_id");
				ㄴ context.getBean이 기본적으로 Object를 반환하기 때문에 두번째 인자로 ClassName.class를 입력해주거나, 형변환을 해줘야함
--------------------------------------------------------------------------------
Spring_Bean Attribute
	ㄴ class : 정규화된 자바 클래스 이름
	ㄴ id : bean의 고유 식별자
	ㄴ scope : 객체의 범위(singleton, prototype)
	ㄴ construcotr-arg : 생성시 생성자에 전달할 인수
		ㄴ bean을 생성자로 받을시에는 ref 속성에 지정 (***** value <-> ref *****)
			ㄴ 사용예시 : <constructor-arg ref="member">  </constructor-arg>
		ㄴ index와 name 속성을 이용해서 애매한 parameter를 지정가능
	ㄴ property : 생성시 bean setter에 전달할 인수
	ㄴ init method와 destroy method
--------------------------------------------------------------------------------
Spring_Bean pvalue
	ㄴ namespace에서 p체크 혹은 beans에 xmlns:p~추가
	ㄴ 쓸 일이 많지 않음	
--------------------------------------------------------------------------------
Spring_Bean Annotation
	ㄴ namespace에서 context추가
		ㄴ 사용예시 : <context:component-scan base-package="target_package"></context:component-scan>
	ㄴ Annotation 종류
		ㄴ @Component : component임을 알림..
			ㄴ@Component("별칭") : 클래스명에서 앞글자만 소문자로 바뀐 id외에 별칭으로 id를 지정하고 싶을 경우에 사용
		ㄴ @Autowired : 생성자 혹은 setter가 없이 주입해주는 어노테이션(DI : Dependency Injection)
		ㄴ @Qualifier("지정하고싶은_id") : 동일한 클래스의 빈이 여러개일 경우 선택해주는 어노테이션
		ㄴ @Resource(name="지정하고싶은_id") : autowired와 qualifier를 같이 사용한 효과
		ㄴ @Inject : @Autowired와 동일한 기능
		ㄴ 클래스를 분류하기 위한 Annotation(기본적으로 @Component를 상속한 Annotation)
			ㄴ @Service : 비즈니스 로직을 처리하는 Serivce 클래스임을 알림
			ㄴ @Repository : 데이터베이스 연동을 처리하는 DAO 클래스
			ㄴ @Controller : 사용자 요청을 제어하는 Controller 클래스
		ㄴ @RequestMapping : controller 클래스 내부 메소드들에서 사용
			ㄴ 사용예시 : @RequestMapping("/start.do") // start.do url이 들어올경우에만 mapping을 함
	ㄴ bean을 이용해서 객체 생성시 클래스 이름에서 맨 앞글자를 소문자로 바꾼 형태로 자동으로 만들어줌
--------------------------------------------------------------------------------
Spring_Bean DI
	ㄴ Autowired : setter, constructor가 없지만 Spring 내부적으로 객체를 관리해주고 그 객체를 인지하고 있음
		ㄴ 의존성 주입(Dependancy Injection)
--------------------------------------------------------------------------------
AOP : Aspect Oriented Programming
	ㄴ 핵심기능(Business Logic)과 횡단관심사(Cross-Cutting Concern)
		ㄴ Business Logic : 업무 로직을 포함하는 기능
		ㄴ Cross-Cutting Concern : 핵심기능을 도와주는 부가기능
			ㄴ Logging
			ㄴ Security
			ㄴ Transaction
	ㄴ Application에서의 핵심적인 기능에서 부가적인 기능을 분리
		ㄴ 분리한 부가기능을 Aspect라는 독특한 Module의 형태로 만들어서 설계하고 개발하는 방법
	ㄴ 반복되는 작업들을 Advice로 묶어 원하는 호출지점인 각각의 pointcut에 weaving (기존에 반복되던 작업들을 method로 묶어서 호출하던 것과 다름)
--------------------------------------------------------------------------------
AOP 용어
	ㄴ 타겟(Target) : 핵심기능을 담고 있는 모듈로, 타겟은 부가기능을 부여할 대상
	ㄴ 어드바이스(Advice) : 횡단관심사를 실제로 구현해서 처리하는 부분
	ㄴ 조인 포인트(Join Point) : 횡단관심사가 실행되는 시점
	ㄴ 포인트컷(PointCut) : Advice를 적용할 Target의 method를 선별하는 정규표현식(Regular Expression)
	ㄴ Aspect : AOP의 단위가 되는 횡단관심사
	ㄴ Weaving : 위빙은 포인트컷에 의해서 결정된 타켓의 조인포인트에 부가기능을 삽입하는 과정
--------------------------------------------------------------------------------
AOP Advice의 종류
	ㄴ Around : JoinPoint 의 앞과 뒤에서 실행되는 Advice
	ㄴ Before
	ㄴ After
	ㄴ After Returning : Joinpoint 메소드 호출이 정상적으로 종료된 뒤에 실행되는 Advice
	ㄴ After Throwing : 예외가 던져질 때 실행되는 Advice
--------------------------------------------------------------------------------
AOP 사용 예시
	ㄴ xml 구조
		ㄴ <aop:config>
			<aop:pointcut expression="execution(access_modifier return_type_expression file_path_expression method_expression(param_type_expression) )"></aop:pointcut>
				ㄴ param_type_expression : (..) -> 매개변수를 신경쓰지 않음
			<aop:aspect id='my_aspect_id' ref='my_advice_id' order='my_aspect_sequence'>
				<aop:~>
					ㄴaop:의 종류 : aop:before, aop:around ..
				</aop:~>
			</aop:aspect>
		    </aop:config>
	ㄴ annotation 방식
		ㄴ In XML : Spring 내부적으로 자동연결하는 방법
			ㄴ <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
		ㄴ @Around("execution(access_modifier return_type_expression file_path_expression method_expression(param_type_expression) )")
		ㄴ @Aspect : Around annotation이 붙어있는 객체의 앞에 @Component와 같이 붙임
--------------------------------------------------------------------------------
